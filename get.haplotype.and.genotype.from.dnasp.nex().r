#last edited at 20200102

#a function to get genotypes according to haplotypes in .nex file generated by "dnasp"

library(Biostrings)
library(stringr)
library(magrittr)
library(tibble)
library(Biobase)
source(file="https://github.com/ywd5/r-zm/raw/master/mergeIUPACLetters.for.2.sequences().r")
source(file="https://github.com/ywd5/r-zm/raw/master/alview.reversion().r")
source(file="https://github.com/ywd5/r-zm/raw/master/site.polymorphism().r")
source(file="https://github.com/ywd5/r-zm/raw/master/as.DNAStringSet().r")

get.haplotype.and.genotype.from.dnasp.nex=function(dnasp.nex,sample.tsv,primer){
  x="this function is used to interpret nexus file generated by dnasp only. to read normal"
  x="nexus file, use rncl::rncl(), phylobase::readNexus() or ape::read.nexus.data()"
  rm(x)#x serves as annotation here
  #>>>internal functions begin>>>
  f_interpret_nexus=function(nexus){
    #for internal usage only
    nexus=readLines(con=nexus)
    if(length(nexus)==0){stop("file specified by \"nexus\" is empty.")}
    #>>>remove trailing comments and blank in nexus begin>>>
    nexus=sub(pattern="#[^\\]]*$",replacement="",x=nexus)#this code isn't efficient and robust enough
    nexus=sub(pattern=" +$",replacement="",x=nexus)
    nexus=nexus[nexus!=""]
    if(length(nexus)==0){stop("file specified by \"nexus\" contain only comments or spaces.")}
    #<<<remove trailing comments and blank in nexus end<<<
    #>>>pick 2 parts of haploid information and haploid sequences from nexus begin>>>
    msu=c("BEGIN TAXA;","BEGIN CHARACTERS;","BEGIN CODONS;",
          "BEGIN CODONUSAGE;","BEGIN SETS;","BEGIN DnaSP;")
    spbu="END;"
    #
    ans=match(x=msu,table=nexus)
    if(anyNA(ans)){stop("component number of .nex file generated by dnasp have decreased");}
    if(length(intersect(msu,nexus[-ans]))>0){stop("component names of .nex file have duplications.");}
    msu=ans
    rm(ans)
    spbu=(1:length(nexus))[nexus==spbu]
    if(length(spbu)!=length(msu)){stop("component number of .nex file generated by dnasp have increased");}
    #
    result=list(sample=nexus[ (spbu[1]+1):(msu[2]-1) ],
                sequence=nexus[ (msu[2]+1):(spbu[2]-1) ])
    if(length(result$sample)==0){stop("the component between TAXA and CHARACTERS is empty.")}
    if(length(result$sequence)==0){stop("the component of CHARACTERS is empty.")}
    rm(msu,spbu,nexus)
    #<<<pick 2 parts of haploid information and haploid sequences from nexus end<<<
    l=c(length(result$sample),length(result$sequence))
    names(l)=c("sample","sequence")
    #>>>remove number-index sample part, and preserve name-index sample part begin>>>
    ans="[Hap#  Freq. Sequences]"
    if(all(result$sample!=ans)){stop("there should be 2 lines as \"[Hap#  Freq. Sequences]\".")}
    ans=( 1:l[1] )[ result$sample==ans ]
    if(length(ans)!=2){stop("the line \"[Hap#  Freq. Sequences]\" should occur twice.")}
    if(ans[1]!=1){stop("the 1st line should be \"[Hap#  Freq. Sequences]\".")}
    if( ans[2]*2-2!=l[1] ){stop("the 2 parts of \"[Hap#  Freq. Sequences]\" should be equal long.")}
    result$sample=result$sample[ (ans[2]+1):l[1] ]
    l[1]=l[1]/2-1
    if(l[1]==0){stop("the part of \"[Hap#  Freq. Sequences]\" can't be empty.")}
    rm(ans)
    #<<<remove number-index sample part, and preserve name-index sample part end<<<
    #>>>split the 3-column haplotype and check its validity begin>>>
    if(any(nchar(result$sample)<3)){
      stop("each line in the \"[Hap#  Freq. Sequences]\" part must contain at least 3 characters.");
    }
    if(!all( str_starts(string=result$sample,pattern="\\["),str_ends(string=result$sample,pattern="\\]") )){
      stop("lines in the \"[Hap#  Freq. Sequences]\" part must begin with \"[\" and end with \"]\".")
    }
    result$sample=substr(x=result$sample,start=2,stop=nchar(result$sample)-1)
    #
    tulip=str_match(string=result$sample,pattern="^(Hap_[[:digit:]]+): +([[:digit:]]+) +([^ ].*)$")[,-1,drop=FALSE]
    if(anyNA(tulip[,1])){stop("some lines of the \"[Hap#  Freq. Sequences]\" part can't match on the regular expression.");}
    result$sample=setNames(object=strsplit(tulip[,3],split=" +"),nm=tulip[,1])
    if(!identical( unname(lengths(result$sample)),as.integer(tulip[,2]) )){
      stop("in the part of \"[Hap#  Freq. Sequences]\", haploid frequencies don't match numbers of samples.")
    }
    rm(tulip)
    #<<<split the 3-column haplotype and check its validity end<<<
    #>>>get haploid sequence strings from result$sequence begin>>>
    msu=(1:l[2])[result$sequence=="MATRIX"]
    spbu=(1:l[2])[result$sequence==";"]
    if(length(msu)!=1){stop("in the CHARACTER part, there should be a multi-line component named \"MATRIX\".")}
    if(msu!=3){warning("in the CHARACTER part, the line as \"MATRIX\" should occur at the 3rd position.")}
    if(length(spbu)!=1){stop("in the CHARACTER part, there should be only one multi-line component.")}
    if(spbu!=l[2]){warning("multi-line component \"matrix\" of the CHARACTER part, should occur at last.")}
    result$sequence=result$sequence[ (msu+1):(spbu-1) ]
    l[2]=spbu-msu-1
    if(l[2]<3){stop("\"matrix\" component of the CHARACTER part is empty.")}
    rm(msu,spbu)
    #
    if(!grepl(pattern="^\\[[ [:digit:]]+\\]$",x=result$sequence[1])){
      stop("structure of the 1st line of \"matrix\" component of the CHARACTER part is invalid.")
    }
    if(!grepl(pattern="^\\[[ *]+\\]$",x=result$sequence[2])){
      stop("structure of the 2nd line of \"matrix\" component of the CHARACTER part is invalid.")
    }
    result$sequence=result$sequence[-c(1,2)]
    l[2]=l[2]-2
    #<<<get haploid sequence strings from result$sequence end<<<
    if(l[1]!=l[2]){stop("number of haplotypes aren't same between the 2 parts of nexus file.")}
    if(any( names(result$sample)!=str_extract(names(result$sequence),pattern="^([^ ]+)")  )){
      stop("haploid names are in chaos in \"nexus\".")
    }
    return(result)#rm(result,l)
  }
  #<<<internal functions end<<<
  #>>>control the input of dnasp.nex, sample.tsv and primer begin>>>
  if(!is.vector(dnasp.nex)|is.list(dnasp.nex)){stop("dnasp.nex must be a character string.")}
  if(!is.vector(sample.tsv)|is.list(sample.tsv)){stop("sample.tsv must be a character string.")}
  if(!is.vector(primer)|is.list(primer)){stop("primer must be a character string.")}
  if(length(dnasp.nex)!=1|length(sample.tsv)!=1|length(primer)!=1){
    stop("dnasp.nex, sample.tsv and primer must contain 1 item.")
  }
  dnasp.nex=as.character(dnasp.nex)
  sample.tsv=as.character(sample.tsv)
  primer=as.character(primer) %>% str_trim(side="both")
  if(!file.exists(dnasp.nex)|!file.exists(sample.tsv)){stop("the files dnasp.nex and(or) sample.tsv don't exist.");}
  if(file.size(dnasp.nex)>100*1024*1024|file.size(sample.tsv)>100*1024*1024){
    stop("the function refuse to manipulate on files (dnasp.nex or sample.tsv) larger than ",
         "100MB. if you really want to manipulate it, remove this code snippet.")
  }
  if(primer==""){stop("primer can't be an empty string.")}
  #<<<control the input of dnasp.nex, sample.tsv and primer end<<<
  metainfo=list(hap.l=0,gen.l=0,hash="")
  #>>>get haplotype information from dnasp.nex begin>>>
  haplotype=f_interpret_nexus(nexus=dnasp.nex)
  haplotype=c(list(info=haplotype$sample,distribution=""),haplotype["sequence"],list(snp=""))
  haplotype$info %<>% {tibble(name=names(.),frequency=lengths(.),split_sample=unname(.),sample=unname(.))}
  haplotype$sequence=alview.reversion(strings=haplotype$sequence) %>% as.DNAStringSet()
  if(!setequal( x=haplotype$info$name,y=names(haplotype$sequence) )){
    stop("names of haplotypes are consistent in .nex file")
  }
  if(length(unique(nchar(haplotype$sequence)))!=1|nchar(haplotype$sequence[[1]])==0){
    stop("all haplotype sequences in dnasp.nex must have a same (but not 0) number of residues.")
  }
  metainfo$hap.l=nrow(haplotype$info)
  rm(dnasp.nex)
  #<<<get haplotype information from dnasp.nex end<<<
  #>>>get sample information from sample.tsv and primer begin>>>
  metainfo$hash=read.table(file=sample.tsv,header=TRUE,sep="\t",
                           fileEncoding="UTF-8-BOM",stringsAsFactors=FALSE)
  if(!all( c("population",primer)%in%names(metainfo$hash) )){
    stop("header names in sample.tsv must contain \"population\" and primer")
  }
  metainfo$hash=setNames(object=metainfo$hash[["population"]],nm=metainfo$hash[[primer]])
  if(anyNA(unname(metainfo$hash))|anyNA(names(metainfo$hash))){
    stop("NAs are introduced when importing sample.tsv")
  }
  rm(sample.tsv,primer)
  #<<<get sample information from sample.tsv and primer end<<<
  #>>>check validity of haplotype$info$sample begin>>>
  tulip=unlist(haplotype$info$sample) %>% unname()
  if(anyDuplicated(tulip)!=0){stop("sample names with \"-1\", \"-2\" shouldn't have duplications.")}
  if(!all(str_detect(string=tulip,pattern="-[12]$"))){
    stop("some individual names don't end with -1 nor -2, this may due to long names.")
  }
  rm(tulip)
  for(i in 1:metainfo$hap.l){ haplotype$info$sample[[i]] %<>% {substr(x=.,start=1,stop=nchar(.)-2);} }
  if(unlist(haplotype$info$sample) %>% table() %>% as.integer() %>% {.!=2} %>% any()){
    stop("not all individuals contain exactly 2 haplotypes in dnasp.nex.")
  }
  #
  if(unlist(haplotype$info$sample) %>% unique() %>% {.%in%names(metainfo$hash);} %>% {!all(.)}){
    stop("some sample names in dnasp.nex doesn't occur in sample.tsv")
  }
  #<<<check validity of haplotype$info$sample end<<<
  #>>>get genotype from haplotype begin>>>
  genotype=split(x=rep(haplotype$info$name,times=haplotype$info$frequency),
                 f=unlist(haplotype$info$sample))
  for(i in 1:length(genotype)){genotype[[i]] %<>% str_sort(numeric=TRUE) %>% paste0(collapse="/")}
  genotype=split(x=names(genotype),f=unlist(unname(genotype))) %>% .[ str_order(names(.),numeric=TRUE) ]
  metainfo$gen.l=length(genotype)
  genotype %<>% {tibble(name=paste0("Gen_",1:metainfo$gen.l),component=names(.),frequency=lengths(.),sample=unname(.))}
  genotype=list(info=genotype,distribution="",sequence=rep(DNAStringSet(""),times=metainfo$gen.l),snp="")
  names(genotype$sequence)=genotype$info$name
  #<<<get genotype from haplotype end<<<
  #>>>get genotype$sequence according to genotype$info$component begin>>>
  for(i in 1:metainfo$gen.l){
    ans=genotype$info$component[i] %>% strsplit(split="/") %>% .[[1]]
    ans=haplotype$sequence[ans] %>% as.character() %>% {mergeIUPACLetters.for.2.sequences(.[1],.[2])}
    genotype$sequence[i]=ans
    rm(ans)
  }
  #<<<get genotype$sequence according to genotype$info$component end<<<
  #>>>get haplotype/genotype distribution in population begin>>>
  tulip=haplotype$info$sample
  for(i in 1:metainfo$hap.l){tulip[[i]] %<>% {metainfo$hash[.];} %>% unname()}
  haplotype$distribution=table( unlist(tulip) , rep(haplotype$info$name,times=haplotype$info$frequency) )
  haplotype$distribution %<>% {.[ str_order(rownames(.),numeric=TRUE) , str_order(colnames(.),numeric=TRUE) ]}
  rm(tulip)
  #
  tulip=genotype$info$sample
  for(i in 1:metainfo$gen.l){tulip[[i]] %<>% {metainfo$hash[.];} %>% unname()}
  genotype$distribution=table( unlist(tulip) , rep(genotype$info$name,times=genotype$info$frequency) )
  genotype$distribution %<>% {.[ str_order(rownames(.),numeric=TRUE) , str_order(colnames(.),numeric=TRUE) ]}
  rm(tulip)
  #<<<get haplotype/genotype distribution in population end<<<
  #>>>get haplotype/genotype$snp from haplotype/genotype$sequence begin>>>
  haplotype$sequence=ape::as.DNAbin(haplotype$sequence) %>% as.matrix()
  genotype$sequence=ape::as.DNAbin(genotype$sequence) %>% as.matrix()
  haplotype$snp=haplotype$sequence %>% {.[,lengths(site.polymorphism(.))>1];}
  genotype$snp=genotype$sequence %>% {.[,lengths(site.polymorphism(.))>1];}
  #<<<get snp from haplotype$sequence and genotype$sequence end<<<
  #>>>convert haplotype/genotype$info for printing begin>>>
  for(i in 1:metainfo$hap.l){
    haplotype$info$split_sample[[i]] %<>% str_sort(numeric=TRUE) %>% paste0(collapse=", ")
  };haplotype$info$split_sample %<>% unlist();
  haplotype$info$sample=NULL#attention!!! this line may not work!!!
  for(i in 1:metainfo$gen.l){
    genotype$info$sample[[i]] %<>% str_sort(numeric=TRUE) %>% paste0(collapse=", ")
  };genotype$info$sample %<>% unlist();
  #<<<convert haplotype/genotype$info for printing end<<<
  #>>>export result begin>>>
  output_name=c("general information","distribution in populations","sequence","snp sequence")
  output_name=paste0(output_name,", ",
                     strftime(Sys.time(),format="%Y%m%d_%H%M%S"),
                     c(".tsv",".tsv",".fasta",".fasta"))
  output_name=paste0(rep(c("haplotype, ","genotype, "),each=4),output_name)
  if(any(file.exists(output_name))){stop("can't create the following files, they already exist.")}
  #
  #as suggested by ?connections, use the following codes to write UTF-8-BOM head explicitly:
  #writeChar("\ufeff",con,eos=NULL) or writeBin(as.raw(c(0xef,0xbb,0xbf)),binary_con)
  writeBin(object=as.raw(c(0xef,0xbb,0xbf)),con=output_name[1]);write.table(
    x=haplotype$info,file=output_name[1],append=TRUE,
    quote=TRUE,sep="\t",eol="\n",row.names=FALSE,col.names=TRUE,fileEncoding="UTF-8")
  writeBin(object=as.raw(c(0xef,0xbb,0xbf)),con=output_name[2]);write.table(
    x=haplotype$distribution,file=output_name[2],append=TRUE,
    quote=TRUE,sep="\t",eol="\n",row.names=TRUE,col.names=NA,fileEncoding="UTF-8")
  writeXStringSet(x=as.DNAStringSet(haplotype$sequence),filepath=output_name[3],width=80)
  writeXStringSet(x=as.DNAStringSet(haplotype$snp),filepath=output_name[4],width=80)
  #
  writeBin(object=as.raw(c(0xef,0xbb,0xbf)),con=output_name[5]);write.table(
    x=genotype$info,file=output_name[5],append=TRUE,
    quote=TRUE,sep="\t",eol="\n",row.names=FALSE,col.names=TRUE,fileEncoding="UTF-8")
  writeBin(object=as.raw(c(0xef,0xbb,0xbf)),con=output_name[6]);write.table(
    x=genotype$distribution,file=output_name[6],append=TRUE,
    quote=TRUE,sep="\t",eol="\n",row.names=TRUE,col.names=NA,fileEncoding="UTF-8")
  writeXStringSet(x=as.DNAStringSet(genotype$sequence),filepath=output_name[7],width=80)
  writeXStringSet(x=as.DNAStringSet(genotype$snp),filepath=output_name[8],width=80)
  #
  message("\nresults are written in the following files:\n",paste0(output_name,collapse="\n"),
          "\nthese values are returned invisibly, you can collect and rename them in batch.\n")
  #<<<export result end<<<
  i=0;rm(f_interpret_nexus,metainfo,haplotype,genotype,i)
  invisible(output_name)#rm(output_name)
}

if(FALSE){
  #here are the test codes
  dnasp.nex="~/../Onedrive/Sep13_atrata/analysis, dnasp/atrata-its.nex"
  sample.tsv="~/../OneDrive/Sep13_atrata/M. atrata population multiply primer.tsv"
  ans=get.haplotype.and.genotype.from.dnasp.nex(dnasp.nex=dnasp.nex,sample.tsv=sample.tsv,primer="its")
  #tempo=paste0("atrata-its, ",ans) %>% gsub(pattern=", [[:digit:]_]{15}\\.",replacement=".",x=.)
  #file.rename(from=ans,to=tempo)
  tempo="";rm(dnasp.nex,sample.tsv,ans,tempo)
}
