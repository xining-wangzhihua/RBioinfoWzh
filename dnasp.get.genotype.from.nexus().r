#last edited at 20191217

#a function to get genotypes according to haplotypes in .nex file generated by "dnasp"

dnasp.get.genotype.from.nexus=function(nexfile){
  x="this function is used to interpret nexus file generated by dnasp only. to read"
  x="general nexus file, use rncl::rncl(), phylobase::readNexus() or ape::read.nexus.data()"
  rm(x)#x serves as annotation here
  #>>>r package dependency, function dependency, internal functions begin>>>
  require(Biostrings)
  require(stringr)
  require(magrittr)
  require(tibble)
  require(Biobase)
  source(file="https://github.com/ywd5/r-zm/raw/master/paste.xml.elements().r")
  source(file="https://github.com/ywd5/r-zm/raw/master/zm.mergeIUPACLetters().r")
  source(file="https://github.com/ywd5/r-zm/raw/master/reverse.alview().r")
  f_interpret_nexus=function(nexus){
    #for internal usage only
    nexus=readLines(con=nexus)
    if(length(nexus)==0){stop("file specified by \"nexus\" is empty.")}
    #>>>remove trailing comments and blank in nexus begin>>>
    nexus=sub(pattern="#[^\\]]*$",replacement="",x=nexus)#this code isn't efficient and robust enough
    nexus=sub(pattern=" +$",replacement="",x=nexus)
    nexus=nexus[nexus!=""]
    if(length(nexus)==0){stop("file specified by \"nexus\" contain only comments or spaces.")}
    #<<<remove trailing comments and blank in nexus end<<<
    #>>>pick 2 parts of haploid information and haploid sequences from nexus begin>>>
    msu=c("BEGIN TAXA;","BEGIN CHARACTERS;","BEGIN CODONS;",
          "BEGIN CODONUSAGE;","BEGIN SETS;","BEGIN DnaSP;")
    spbu="END;"
    #
    ans=match(x=msu,table=nexus)
    if(anyNA(ans)){stop("component number of .nex file generated by dnasp have decreased");}
    if(length(intersect(msu,nexus[-ans]))>0){stop("component names of .nex file have duplications.");}
    msu=ans
    rm(ans)
    spbu=(1:length(nexus))[nexus==spbu]
    if(length(spbu)!=length(msu)){stop("component number of .nex file generated by dnasp have increased");}
    #
    result=list(info=nexus[ (spbu[1]+1):(msu[2]-1) ],
                sequence=nexus[ (msu[2]+1):(spbu[2]-1) ])
    if(length(result$info)==0){stop("the component between TAXA and CHARACTERS is empty.")}
    if(length(result$sequence)==0){stop("the component of CHARACTERS is empty.")}
    rm(msu,spbu,nexus)
    #<<<pick 2 parts of haploid information and haploid sequences from nexus end<<<
    l=c(length(result$info),length(result$sequence))
    names(l)=c("info","sequence")
    #>>>remove number-index sample part, and preserve name-index sample part begin>>>
    ans="[Hap#  Freq. Sequences]"
    if(all(result$info!=ans)){stop("there should be 2 lines as \"[Hap#  Freq. Sequences]\".")}
    ans=( 1:l[1] )[ result$info==ans ]
    if(length(ans)!=2){stop("the line \"[Hap#  Freq. Sequences]\" should occur twice.")}
    if(ans[1]!=1){stop("the 1st line should be \"[Hap#  Freq. Sequences]\".")}
    if( ans[2]*2-2!=l[1] ){stop("the 2 parts of \"[Hap#  Freq. Sequences]\" should be equal long.")}
    result$info=result$info[ (ans[2]+1):l[1] ]
    l[1]=l[1]/2-1
    if(l[1]==0){stop("the part of \"[Hap#  Freq. Sequences]\" can't be empty.")}
    rm(ans)
    #<<<remove number-index sample part, and preserve name-index sample part end<<<
    #>>>split the 3-column haplotype and check its validity begin>>>
    if(any(nchar(result$info)<3)){
      stop("each line in the \"[Hap#  Freq. Sequences]\" part must contain at least 3 characters.");
    }
    if(!all( str_starts(string=result$info,pattern="\\["),str_ends(string=result$info,pattern="\\]") )){
      stop("lines in the \"[Hap#  Freq. Sequences]\" part must begin with \"[\" and end with \"]\".")
    }
    result$info=substr(x=result$info,start=2,stop=nchar(result$info)-1)
    #
    tulip=str_match(string=result$info,pattern="^(Hap_[[:digit:]]+): +([[:digit:]]+) +([^ ].*)$")[,-1,drop=FALSE]
    if(anyNA(tulip[,1])){stop("some lines of the \"[Hap#  Freq. Sequences]\" part can't match on the regular expression.");}
    result$info=setNames(object=strsplit(tulip[,3],split=" +"),nm=tulip[,1])
    if(!identical( unname(lengths(result$info)),as.integer(tulip[,2]) )){
      stop("in the part of \"[Hap#  Freq. Sequences]\", haploid frequencies don't match numbers of individuals.")
    }
    rm(tulip)
    #<<<split the 3-column haplotype and check its validity end<<<
    #>>>get haploid sequences from result$sequence begin>>>
    msu=(1:l[2])[result$sequence=="MATRIX"]
    spbu=(1:l[2])[result$sequence==";"]
    if(length(msu)!=1){stop("in the CHARACTER part, there should be a multi-line component named \"MATRIX\".")}
    if(msu!=3){warning("in the CHARACTER part, the line as \"MATRIX\" should occur at the 3rd position.")}
    if(length(spbu)!=1){stop("in the CHARACTER part, there should be only one multi-line component.")}
    if(spbu!=l[2]){warning("multi-line component \"matrix\" of the CHARACTER part, should occur at last.")}
    result$sequence=result$sequence[ (msu+1):(spbu-1) ]
    l[2]=spbu-msu-1
    if(l[2]<3){stop("\"matrix\" component of the CHARACTER part is empty.")}
    rm(msu,spbu)
    #
    if(!grepl(pattern="^\\[[ [:digit:]]+\\]$",x=result$sequence[1])){
      stop("structure of the 1st line of \"matrix\" component of the CHARACTER part is invalid.")
    }
    if(!grepl(pattern="^\\[[ *]+\\]$",x=result$sequence[2])){
      stop("structure of the 2nd line of \"matrix\" component of the CHARACTER part is invalid.")
    }
    result$sequence=result$sequence[-c(1,2)]
    l[2]=l[2]-2
    result$sequence=str_match(string=result$sequence,pattern="^(Hap_[[:digit:]]+) +([ACGT.-]+)$")[,-1,drop=FALSE]
    result$sequence=setNames(object=result$sequence[,2],nm=result$sequence[,1])
    #<<<get haploid sequences from result$sequence end<<<
    if(l[1]!=l[2]){stop("number of haplotypes aren't same between the 2 parts of nexus file.")}
    if(any( names(result$info)!=names(result$sequence) )){stop("haploid names are in chaos in \"nexus\".")}
    return(result)#rm(result,l)
  }
  #<<<r package dependency, function dependency, internal functions end<<<
  #>>>control the input of nexus begin>>>
  if(!is.vector(nexfile)|is.list(nexfile)){stop("\"nexfile\" must be a character string.")}
  if(length(nexfile)!=1){stop("\"nexfile\" must contain 1 item.")}
  nexfile=as.character(nexfile)
  if(!file.exists(nexfile)){stop("file specified by \"nexus\" doesn't exist.")}
  if(file.size(nexfile)>100*1024*1024){
    stop("the function refuse to manipulate on files larger than 100MB.",
         "if you really want to manipulate it, remove this code snippet.")
  }
  #<<<control the input of nexus end<<<
  #>>>get information from nexus file and interpret dots in following sequences according to 1st sequence begin>>>
  nexfile=f_interpret_nexus(nexus=nexfile)
  l=c(length(nexfile$info),0)
  names(l)=c("haplotype","genotype")
  if(l[1]>1)for(i in 2:l[1]){
    nexfile$sequence[i]=reverse.alview(seq=nexfile$sequence[i],ref=nexfile$sequence[1])
  }
  #<<<get information from nexus file and interpret dots in following sequences according to 1st sequence end<<<
  #>>>check validity of individual names stored in nexfile$info begin>>>
  ans=unlist(nexfile$info) %>% unname()
  if(anyDuplicated(ans)!=0){stop("individual names with \"-1\", \"-2\" shouldn't have duplications.")}
  if(!all(str_ends(string=ans,pattern="-[12]"))){
    stop("some individual names don't end with -1 nor -2, this may due to long names.")
  }
  rm(ans)
  for(i in 1:l[1]){nexfile$info[[i]]=substr(x=nexfile$info[[i]],start=1,stop=nchar(nexfile$info[[i]])-2);}
  if(unlist(nexfile$info) %>% table() %>% {as.integer(.)!=2} %>% any()){
    stop("not all individual are split into 2 haplotypes in \"nexfile\".")
  }
  #<<<check validity of individual names stored in nexfile$info end<<<
  #>>>resolve relationship of genotype&individual according to relationship of haplotype&individual begin>>>
  result=reverseSplit(inList=nexfile$info)
  for(i in 1:length(result)){result[[i]]=str_sort(result[[i]],numeric=TRUE) %>% paste0(collapse="/")}
  result=reverseSplit(inList=result)
  #<<<resolve relationship of genotype&individual according to relationship of haplotype&individual end<<<
  #>>>generate the structure of result begin>>>
  result=tibble(id="",genotype=names(result),h1="",h2="",frequency=0,individual=unname(result),sequence="")
  l[2]=nrow(result)
  for(i in 1:l[2]){result$individual[[i]]=str_sort(result$individual[[i]],numeric=TRUE);}
  result=result[str_order(result$genotype,numeric=TRUE),]
  #<<<generate the structure of result end<<<
  #>>>calculate result$id, result$h1, result$h2, result$frequency, result$sequence begin>>>
  result$id=paste0("G",1:l[2])
  ans=strsplit(result$genotype,split="/") %>% as_tibble(.name_repair="minimal") %>% t()
  result$h1=ans[,1]
  result$h2=ans[,2]
  rm(ans)
  result$frequency=lengths(result$individual) %>% unname()
  for(i in 1:l[2]){
    msu=result$h1[i] %>% nexfile$sequence[.]
    spbu=result$h2[i] %>% nexfile$sequence[.]
    result$sequence[i]=zm.mergeIUPACLetters(seq1=msu,seq2=spbu)
    rm(msu,spbu)
  }
  #<<<calculate result$id, result$h1, result$h2, result$frequency, result$sequence end<<<
  #>>>change datum into strings for pretty printing begin>>>
  result$id=paste.xml.elements(names="genotype",values=as.list(result$id))
  result$genotype=paste.xml.elements(names="component",values=as.list(result$genotype))
  result$frequency=paste.xml.elements(names="frequency",values=as.list(result$frequency))
  for(i in 1:l[2]){
    result$individual[[i]]=paste0(result$individual[[i]],collapse=", ")
  }
  result$individual=unlist(result$individual)
  result$individual=paste.xml.elements(names="individual",values=as.list(result$individual))
  result$sequence=paste0("\n",result$sequence,"\n")
  result$sequence=paste.xml.elements(names="sequence",values=as.list(result$sequence))
  #
  result$sequence=paste0(result$id,result$genotype,result$frequency,result$individual,result$sequence)
  result$sequence=sub(pattern="\n$",replacement="",x=result$sequence)
  result$sequence=paste0("<branch id=\"",1:l[2],"\">",result$sequence,"</branch>\n\n")
  #<<<change datum into strings for pretty printing end<<<
  #>>>output datum to a file begin>>>
  output_name=as.character(Sys.time()) %>% strsplit(split="[- :]") %>% .[[1]] %>% {list(.[1:3],.[4:6])}
  output_name[[1]]=paste0(output_name[[1]],collapse="")
  output_name[[2]]=paste0(output_name[[2]],collapse="")
  output_name=paste0("genotype from nex via r, ",output_name[[1]],"_",output_name[[2]],".xml")
  cat("<root>\n\n",result$sequence,"</root>\n",file=output_name,append=FALSE,sep="")
  message("\nresult of genotype is written to \"./",output_name,"\"\nplease check before using to avoid bug.\n")
  #<<<output datum to a file end<<<<
  i=0;rm(f_interpret_nexus,l,i,nexfile,result)
  invisible(output_name)#rm(output_name)
}

if(FALSE){
  #here are the test codes
  nexfile="?must specify?"
  dnasp.get.genotype.from.nexus(nexfile=nexfile)
}
